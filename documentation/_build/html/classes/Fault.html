<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Fault class &#8212; CSI 1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=62c01f10" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=f78ba3b0" />
    <script src="../_static/documentation_options.js?v=f2a433a1"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/clipboard.min.js?v=e637711f"></script>
    <script src="../_static/copybutton.js?v=56c01ce6"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="fault3D class" href="fault3D.html" />
    <link rel="prev" title="Classes of faults" href="../faultclasses.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="fault-class">
<h1>Fault class<a class="headerlink" href="#fault-class" title="Link to this heading">¶</a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="csi.Fault">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">csi.</span></span><span class="sig-name descname"><span class="pre">Fault</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">utmzone</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ellps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'WGS84'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lon0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault" title="Link to this definition">¶</a></dt>
<dd><p>Parent class implementing what is common in all fault objects.</p>
<p>You can specify either an official utm zone number or provide
longitude and latitude for a custom zone.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>name          : Name of the fault.</p></li>
<li><p>utmzone       : UTM zone  (optional, default=None)</p></li>
<li><p>lon0          : Longitude defining the center of the custom utm zone</p></li>
<li><p>lat0          : Latitude defining the center of the custom utm zone</p></li>
<li><p>ellps         : ellipsoid (optional, default=’WGS84’)</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.addfaults">
<span class="sig-name descname"><span class="pre">addfaults</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.addfaults" title="Link to this definition">¶</a></dt>
<dd><p>Add some other faults to plot with the modeled one.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>filename  : Name of the file. File is ascii format. First column is longitude. Second column is latitude. Separator between faults is &gt; as in GMT style</p></li>
</ul>
</dd>
<dt>Return:</dt><dd><ul class="simple">
<li><p>None</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.assembleCd">
<span class="sig-name descname"><span class="pre">assembleCd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">datas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">add_prediction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.assembleCd" title="Link to this definition">¶</a></dt>
<dd><p>Assembles the data covariance matrices that have been built for each
data structure.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>datas         : List of data instances or one data instance</p></li>
</ul>
</dd>
<dt>Kwargs:</dt><dd><ul class="simple">
<li><p>add_prediction: Precentage of displacement to add to the Cd diagonal to simulate a Cp (dirty version of a prediction error covariance, see Duputel et al 2013, GJI).</p></li>
<li><p>verbose       : Talk to me (overwrites self.verbose)</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>None</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.assembleGFs">
<span class="sig-name descname"><span class="pre">assembleGFs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">datas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">polys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slipdir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sdt'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">custom</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">computeNormFact</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.assembleGFs" title="Link to this definition">¶</a></dt>
<dd><p>Assemble the Green’s functions corresponding to the data in datas.
This method allows to specify which transformation is going
to be estimated in the data sets, through the polys argument.</p>
<p>Assembled Green’s function matrix is stored in self.Gassembled</p>
<dl>
<dt>Args:</dt><dd><ul class="simple">
<li><p>datas : list of data sets. If only one data set is used, can be a data instance only.</p></li>
</ul>
</dd>
<dt>Kwargs:</dt><dd><ul>
<li><p>polys : None, nothing additional is estimated</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>For InSAR, Optical, GPS:</dt><dd><ul>
<li><p>1: estimate a constant offset</p></li>
<li><p>3: estimate z = ax + by + c</p></li>
<li><p>4: estimate z = axy + bx + cy + d</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>For GPS only:</dt><dd><ul>
<li><p>‘full’      : Estimates a rotation, translation and scaling (Helmert transform).</p></li>
<li><p>‘strain’    : Estimates the full strain tensor (Rotation + Translation + Internal strain)</p></li>
<li><p>‘strainnorotation’   : Estimates the strain tensor and a translation</p></li>
<li><p>‘strainonly’    : Estimates the strain tensor</p></li>
<li><p>‘strainnotranslation’   : Estimates the strain tensor and a rotation</p></li>
<li><p>‘translation’   : Estimates the translation</p></li>
<li><p>‘translationrotation    : Estimates the translation and a rotation</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</li>
<li><p>slipdir   : Directions of slip to include. Can be any combination of s (strike slip), d (dip slip), t (tensile), c (coupling)</p></li>
<li><p>custom    : If True, gets the additional Green’s function from the dictionary self.G[data.name][‘custom’]</p></li>
<li><p>computeNormFact   : bool. if True, compute new OrbNormalizingFactor. if False, uses parameters in self.OrbNormalizingFactor</p></li>
<li><p>verbose   : Talk to me (overwrites self.verbose)</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>None</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.assembled">
<span class="sig-name descname"><span class="pre">assembled</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">datas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.assembled" title="Link to this definition">¶</a></dt>
<dd><p>Assembles a data vector for inversion using the list datas
Assembled vector is stored in self.dassembled</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>datas         : list of data objects</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>None</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.buildCm">
<span class="sig-name descname"><span class="pre">buildCm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sigma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lam</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lam0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.buildCm" title="Link to this definition">¶</a></dt>
<dd><p>Builds a model covariance matrix using the equation described in
Radiguet et al 2010. We use</p>
<p><span class="math notranslate nohighlight">\(C_m(i,j) = \frac{\sigma \lambda_0}{ \lambda }^2 e^{-\frac{||i,j||_2}{ \lambda }}\)</span></p>
<p>extra_params allows to add some diagonal terms and expand the size
of the matrix, in case the fault object is also hosting the estimation
of transformation parameters.</p>
<p>Model covariance is stored in self.Cm</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>sigma         : Amplitude of the correlation.</p></li>
<li><p>lam           : Characteristic length scale.</p></li>
</ul>
</dd>
<dt>Kwargs:</dt><dd><ul class="simple">
<li><p>lam0          : Normalizing distance. if None, lam0=min(distance between patches)</p></li>
<li><p>extra_params  : A list of extra parameters.</p></li>
<li><p>lim           : Limit distance parameter (see self.distancePatchToPatch)</p></li>
<li><p>verbose       : Talk to me (overwrites self.verrbose)</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>None</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.buildCmGaussian">
<span class="sig-name descname"><span class="pre">buildCmGaussian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sigma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.buildCmGaussian" title="Link to this definition">¶</a></dt>
<dd><p>Builds a diagonal Cm with sigma values on the diagonal.
Sigma is a list of numbers, as long as you have components of slip (1, 2 or 3).
extra_params allows to add some diagonal terms and expand the size
of the matrix, in case the fault object is also hosting the estimation
of transformation parameters.</p>
<p>Model covariance is hold in self.Cm</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>sigma         : List of numbers the size of the slip components requried for the modeling</p></li>
</ul>
</dd>
<dt>Kwargs:</dt><dd><ul class="simple">
<li><p>extra_params   : a list of extra parameters.</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>None</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.buildCmLaplacian">
<span class="sig-name descname"><span class="pre">buildCmLaplacian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lam</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">diagFact</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sensitivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'distance'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sensitivityNormalizing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">irregular</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.buildCmLaplacian" title="Link to this definition">¶</a></dt>
<dd><p>Implements the Laplacian smoothing with sensitivity (optional) into
a model covariance matrix. Description can be found in
F. Ortega-Culaciati’s PhD thesis.</p>
<p>extra_params allows to add some diagonal terms and expand the size
of the matrix, in case the fault object is also hosting the estimation
of transformation parameters.</p>
<p>Model covariance is hold in self.Cm</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>lam                       : Damping factor (list of size of slipdirections)</p></li>
</ul>
</dd>
<dt>Kwargs:</dt><dd><ul class="simple">
<li><p>extra_params              : a list of extra parameters.</p></li>
<li><p>sensitivity               : Weights the Laplacian by Sensitivity (default True)</p></li>
<li><p>sensitivityNormalizing    : Normalizing the Sensitivity?</p></li>
<li><p>method                    : which method to use to build the Laplacian operator</p></li>
<li><p>irregular                 : Only used for rectangular patches. Allows to account for irregular meshing along dip.</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>None</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.buildCmSensitivity">
<span class="sig-name descname"><span class="pre">buildCmSensitivity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sigma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lam</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lam0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.buildCmSensitivity" title="Link to this definition">¶</a></dt>
<dd><p>Builds a model covariance matrix using the equation described in Radiguet et al 2010.
We use</p>
<p><span class="math notranslate nohighlight">\(C_m(i,j) = \frac{\sigma\lambda_0}{\lambda}^2 e^{-\frac{||i,j||_2}{\lambda}}\)</span></p>
<p>Then correlation length is weighted by the sensitivity matrix described in Ortega’s PhD thesis:
<span class="math notranslate nohighlight">\(S = diag(G'G)\)</span></p>
<p>Here, Sigma and Lambda are lists specifying values for the slip directions</p>
<p>extra_params allows to add some diagonal terms and expand the size
of the matrix, in case the fault object is also hosting the estimation
of transformation parameters.</p>
<p>Model covariance is stored in self.Cm</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>sigma         : Amplitude of the correlation.</p></li>
<li><p>lam           : Characteristic length scale.</p></li>
</ul>
</dd>
<dt>Kwargs:</dt><dd><ul class="simple">
<li><p>lam0          : Normalizing distance. if None, lam0=min(distance between patches)</p></li>
<li><p>extra_params  : a list of extra parameters.</p></li>
<li><p>lim           : Limit distance parameter (see self.distancePatchToPatch)</p></li>
<li><p>verbose       : Talk to me (overwrites self.verrbose)</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>None</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.buildCmSlipDirs">
<span class="sig-name descname"><span class="pre">buildCmSlipDirs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sigma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lam</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lam0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.buildCmSlipDirs" title="Link to this definition">¶</a></dt>
<dd><p>Builds a model covariance matrix using the equation described in
Radiguet et al 2010. Here, Sigma and Lambda are lists specifying
values for the slip directions. We use</p>
<p><span class="math notranslate nohighlight">\(C_m(i,j) = \frac{\sigma\lambda_0}{\lambda}^2 e^{-\frac{||i,j||_2}{\lambda}}\)</span></p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>sigma         : Amplitude of the correlation.</p></li>
<li><p>lam           : Characteristic length scale.</p></li>
</ul>
</dd>
<dt>Kwargs:</dt><dd><ul class="simple">
<li><p>lam0          : Normalizing distance. If None, lam0=min(distance between patches)</p></li>
<li><p>extra_params  : A list of extra parameters.</p></li>
<li><p>lim           : Limit distance parameter (see self.distancePatchToPatch)</p></li>
<li><p>verbose       : Talk to me (overwrites self.verrbose)</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>None</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.buildCmXY">
<span class="sig-name descname"><span class="pre">buildCmXY</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sigma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lam</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lam0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.buildCmXY" title="Link to this definition">¶</a></dt>
<dd><p>Builds a model covariance matrix using the equation described in
Radiguet et al 2010 with a different characteristic lengthscale along
the horizontal and vertical directions. We use</p>
<p><span class="math notranslate nohighlight">\(C_m(i,j) = \frac{\sigma \lambda_0}{ \lambda_x }^2 e^{-\frac{||i,j||_{x2}}{ \lambda_x }} \frac{\sigma \lambda_0}{ \lambda_z }^2 e^{-\frac{||i,j||_{z2}}{ \lambda_z }}\)</span></p>
<p>extra_params allows to add some diagonal terms and expand the size
of the matrix, in case the fault object is also hosting the estimation
of transformation parameters.</p>
<p>Model covariance is stored in self.Cm</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>sigma         : Amplitude of the correlation.</p></li>
<li><p>lam           : Characteristic length scale (lamx, lamz)</p></li>
</ul>
</dd>
<dt>Kwargs:</dt><dd><ul class="simple">
<li><p>lam0          : Normalizing distance. if None, lam0=min(distance between patches)</p></li>
<li><p>extra_params  : A list of extra parameters.</p></li>
<li><p>lim           : Limit distance parameter (see self.distancePatchToPatch)</p></li>
<li><p>verbose       : Talk to me (overwrites self.verrbose)</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>None</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.buildGFs">
<span class="sig-name descname"><span class="pre">buildGFs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slipdir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sd'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'homogeneous'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convergence</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.buildGFs" title="Link to this definition">¶</a></dt>
<dd><p>Builds the Green’s function matrix based on the discretized fault.</p>
<p>The Green’s function matrix is stored in a dictionary.
Each entry of the dictionary is named after the corresponding dataset.
Each of these entry is a dictionary that contains ‘strikeslip’, ‘dipslip’,
‘tensile’ and/or ‘coupling’</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>data          : Data object (gps, insar, optical, …)</p></li>
</ul>
</dd>
<dt>Kwargs:</dt><dd><ul class="simple">
<li><p>vertical      : If True, will produce green’s functions for the vertical displacements in a gps object.</p></li>
<li><p>slipdir       : Direction of slip along the patches. Can be any combination of s (strikeslip), d (dipslip), t (tensile) and c (coupling)</p></li>
<li><p>method        : Can be ‘okada’ (Okada, 1982) (rectangular patches only), ‘meade’ (Meade 2007) (triangular patches only), ‘edks’ (Zhao &amp; Rivera, 2002), ‘homogeneous’ (Okada for rectangles, Meade for triangles)</p></li>
<li><p>verbose       : Writes stuff to the screen (overwrites self.verbose)</p></li>
<li><p>convergence   : If coupling case, needs convergence azimuth and rate [azimuth in deg, rate]</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>None</p></li>
</ul>
</dd>
</dl>
<section id="todo-implement-the-homogeneous-case-for-the-node-based-triangular-gfs">
<h2>TODO: Implement the homogeneous case for the Node-based triangular GFs<a class="headerlink" href="#todo-implement-the-homogeneous-case-for-the-node-based-triangular-gfs" title="Link to this heading">¶</a></h2>
</section>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.calcGFsCp">
<span class="sig-name descname"><span class="pre">calcGFsCp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">datasets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">edks_params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.calcGFsCp" title="Link to this definition">¶</a></dt>
<dd><p>Calculate Green’s Functions using Okada or EDKS 
Used in class uncertainties</p>
<dl class="field-list simple">
<dt class="field-odd">Args<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><dl class="simple">
<dt>datasets<span class="classifier">List of data objects</span></dt><dd><p>ex: dataset=[gps]+[insar1,insar2]</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt class="field-even">Kwargs<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><dl class="simple">
<dt>edks<span class="classifier">If True, GFs calculated using a layered Earth model calculated with EDKS.</span></dt><dd><p>If False, GFs with Okada</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<dl>
<dt>If edks is True, please specify in <a href="#id1"><span class="problematic" id="id2">**</span></a>edks_params: </dt><dd><p>ex: Cp_dip(fault,datasets,[40,50],multi_segments=2,edks=True,edksdir=’PATH’,modelname=’CIA’,sourceSpacing=0.5)
* modelname : xxx.edks = Filename of the EDKS kernels
* sourceSpacing      : source spacing to calculate the Green’s Functions</p>
<blockquote>
<div><p>OR sourceNumber   : Number of sources per patches.
OR sourceArea     : Maximum Area of the sources.</p>
</div></blockquote>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p>Gassembled</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.cumdis2xy">
<span class="sig-name descname"><span class="pre">cumdis2xy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">distance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">recompute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'lonlat'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">discretized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.cumdis2xy" title="Link to this definition">¶</a></dt>
<dd><p>For a given {distance}, returns the x and y position along strike.</p>
<dl class="simple">
<dt>Args:   </dt><dd><ul class="simple">
<li><p>distance          : Along strike distance</p></li>
</ul>
</dd>
<dt>Kwargs:</dt><dd><ul class="simple">
<li><p>recompute         : recompute the interpolator</p></li>
<li><p>mode              : ‘lonlat’ returns lon/lat while ‘xy’ returns x and y</p></li>
<li><p>discretized       : use the discretized fault trace</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>xy                : tuple of floats</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.cumdistance">
<span class="sig-name descname"><span class="pre">cumdistance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">discretized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">recompute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.cumdistance" title="Link to this definition">¶</a></dt>
<dd><p>Computes the distance between the first point of the fault and every
other point. The distance is cumulative along the fault.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>discretized           : if True, use the discretized fault trace (default False)</p></li>
<li><p>recompute             : if False, just returns the attribute cumdis</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>dis                   : Cumulative distance array</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.discretize">
<span class="sig-name descname"><span class="pre">discretize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">every</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fracstep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xaxis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'x'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cum_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.discretize" title="Link to this definition">¶</a></dt>
<dd><p>Refine the surface fault trace by setting a constant distance between
each point. Pay attention, the fault cannot be exactly a straight
line north-south. Descretized fault trace is stored in self.xi and
self.yi</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><ul class="simple">
<li><p>every         : Spacing between each point (in km)</p></li>
<li><p>tol           : Tolerance in the spacing (in km)</p></li>
<li><p>fracstep      : fractional step in the chosen direction for the discretization optimization</p></li>
<li><p>xaxis         : Axis for the discretization. ‘x’= use x as the axis, ‘y’= use y as the axis</p></li>
<li><p>cum_error     : if True, accounts for cumulated error to define the axis bound for the last patch</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>None</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.distance2trace">
<span class="sig-name descname"><span class="pre">distance2trace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">discretized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coord</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ll'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">recompute</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.distance2trace" title="Link to this definition">¶</a></dt>
<dd><p>Computes the distance between a point and the trace of a fault.
This is a slow method, so it has been recoded in a few places
throughout the whole library.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>lon               : Longitude of the point.</p></li>
<li><p>lat               : Latitude of the point.</p></li>
</ul>
</dd>
<dt>Kwargs:</dt><dd><ul class="simple">
<li><p>discretized       : Uses the discretized trace.</p></li>
<li><p>recompute         : recompute the cumulative distance</p></li>
<li><p>coord             : if ‘ll’ or ‘lonlat’, input in degree. If ‘xy’ or ‘utm’, input in km</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>dalong            : Distance to the first point of the fault along the fault</p></li>
<li><p>dacross           : Shortest distance between the point and the fault</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.dropPointSources">
<span class="sig-name descname"><span class="pre">dropPointSources</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.dropPointSources" title="Link to this definition">¶</a></dt>
<dd><p>Drops point sources along the fault. Point sources can then be used
to compute GFs using the EDKS software.</p>
<dl class="simple">
<dt>The process is controlled by the attributes:</dt><dd><ul class="simple">
<li><p>self.sourceSpacing      : Distance between sources</p></li>
<li><p>self.sourceArea         : Area of the sources</p></li>
<li><p>self.sourceNumber       : Number of sources per patch</p></li>
</ul>
</dd>
</dl>
<p>One needs to set at least one of those three attributes.</p>
<p>Sources are saved in self.plotSources and self.edksSources</p>
<dl class="simple">
<dt>Returns:</dt><dd><ul class="simple">
<li><p>None</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.duplicateFault">
<span class="sig-name descname"><span class="pre">duplicateFault</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.duplicateFault" title="Link to this definition">¶</a></dt>
<dd><p>Returns a full copy (copy.deepcopy) of the fault object.</p>
<dl class="simple">
<dt>Return:</dt><dd><ul class="simple">
<li><p>fault         : fault object</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.edksGFs">
<span class="sig-name descname"><span class="pre">edksGFs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slipdir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sd'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convergence</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'fortran'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.edksGFs" title="Link to this definition">¶</a></dt>
<dd><p>Builds the Green’s functions based on the solution by Zhao &amp; Rivera 2002.
The corresponding functions are in the EDKS code that needs to be installed and
the executables should be found in the directory set by the environment
variable EDKS_BIN.</p>
<p>A few variables need to be set in before running this method</p>
<blockquote>
<div><dl class="simple">
<dt>Required:</dt><dd><ul class="simple">
<li><p>self.kernelsEDKS    : Filename of the EDKS kernels.</p></li>
</ul>
</dd>
<dt>One of the Three:</dt><dd><ul class="simple">
<li><p>self.sourceSpacing  : Spacing between the sources in each patch.</p></li>
<li><p>self.sourceNumber   : Number of sources per patches.</p></li>
<li><p>self.sourceArea     : Maximum Area of the sources.</p></li>
</ul>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>data              : Data object</p></li>
</ul>
</dd>
<dt>Kwargs:</dt><dd><ul class="simple">
<li><p>vertical      : If True, will produce green’s functions for the vertical displacements in a gps object.</p></li>
<li><p>slipdir       : Direction of slip along the patches. Can be any combination of s (strikeslip), d (dipslip), t (tensile) and c (coupling)</p></li>
<li><p>verbose       : Writes stuff to the screen (overwrites self.verbose)</p></li>
<li><p>convergence   : If coupling case, needs convergence azimuth and rate [azimuth in deg, rate]</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>G             : Dictionary of the built Green’s functions</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.emptyGFs">
<span class="sig-name descname"><span class="pre">emptyGFs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slipdir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sd'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.emptyGFs" title="Link to this definition">¶</a></dt>
<dd><p>Build zero GFs.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>data          : Data object (gps, insar, optical, …)</p></li>
</ul>
</dd>
<dt>Kwargs:</dt><dd><ul class="simple">
<li><p>vertical      : If True, will produce green’s functions for the vertical displacements in a gps object.</p></li>
<li><p>slipdir       : Direction of slip along the patches. Can be any combination of s (strikeslip), d (dipslip), t (tensile) and c (coupling)</p></li>
<li><p>verbose       : Writes stuff to the screen (overwrites self.verbose)</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>G             : Dictionnary of GFs</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.estimateSeismicityRate">
<span class="sig-name descname"><span class="pre">estimateSeismicityRate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">earthquake</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra_div</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.estimateSeismicityRate" title="Link to this definition">¶</a></dt>
<dd><p>Counts the number of earthquakes per patches and divides by the area of the patches.
Sets the results in</p>
<blockquote>
<div><p>self.earthquakeInPatch (Number of earthquakes per patch) and self.seismicityRate (Seismicity rate for this patch)</p>
</div></blockquote>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>earthquake    : seismiclocation object</p></li>
</ul>
</dd>
<dt>Kwargs:</dt><dd><ul class="simple">
<li><p>extra_div     : Extra divider to get the seismicity rate.</p></li>
<li><p>epsilon       : Epsilon value for precision of earthquake location.</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>None</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.file2trace">
<span class="sig-name descname"><span class="pre">file2trace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">utm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">header</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.file2trace" title="Link to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Reads the fault trace from a text file (ascii 2 columns)</dt><dd><ul class="simple">
<li><p>If utm is False, format is Lon Lat</p></li>
<li><p>If utm is True, format is X Y (in km)</p></li>
</ul>
</dd>
<dt>Args:</dt><dd><ul class="simple">
<li><p>filename      : Name of the fault file.</p></li>
</ul>
</dd>
<dt>Kwargs:</dt><dd><ul class="simple">
<li><p>utm           : Specify nature of coordinates</p></li>
<li><p>header        : Number of lines to skip at the beginning of the file</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>None</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.gaussianSlipSmoothing">
<span class="sig-name descname"><span class="pre">gaussianSlipSmoothing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">length</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.gaussianSlipSmoothing" title="Link to this definition">¶</a></dt>
<dd><p>Smoothes the slip distribution using a Gaussian filter.
Smooth slip distribution is in self.slip</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>length        : Correlation length.</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>None</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.getindex">
<span class="sig-name descname"><span class="pre">getindex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.getindex" title="Link to this definition">¶</a></dt>
<dd><p>Returns the index of a patch.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>p         : Patch from a fault object.</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>iout      : index of the patch</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.getslip">
<span class="sig-name descname"><span class="pre">getslip</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.getslip" title="Link to this definition">¶</a></dt>
<dd><p>Returns the slip vector for a patch or tent</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>p         : patch or tent</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>iout      : Index of the patch or tent</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.homogeneousGFs">
<span class="sig-name descname"><span class="pre">homogeneousGFs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slipdir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sd'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">convergence</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.homogeneousGFs" title="Link to this definition">¶</a></dt>
<dd><p>Builds the Green’s functions for a homogeneous half-space.</p>
<p>If your patches are rectangular, Okada’s formulation is used (Okada, 1982)
If your patches are triangular, Meade’s formulation is used (Meade, 2007)</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>data          : Data object (gps, insar, optical, …)</p></li>
</ul>
</dd>
<dt>Kwargs:</dt><dd><ul class="simple">
<li><p>vertical      : If True, will produce green’s functions for the vertical displacements in a gps object.</p></li>
<li><p>slipdir       : Direction of slip along the patches. Can be any combination of s (strikeslip), d (dipslip), t (tensile) and c (coupling)</p></li>
<li><p>verbose       : Writes stuff to the screen (overwrites self.verbose)</p></li>
<li><p>convergence   : If coupling case, needs convergence azimuth and rate [azimuth in deg, rate]</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>G             : Dictionary of the built Green’s functions</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.initializeEmptyFault">
<span class="sig-name descname"><span class="pre">initializeEmptyFault</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.initializeEmptyFault" title="Link to this definition">¶</a></dt>
<dd><p>Initializes what is required for a fualt with no patches</p>
<dl class="simple">
<dt>Returns: </dt><dd><ul class="simple">
<li><p>None</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.initializeslip">
<span class="sig-name descname"><span class="pre">initializeslip</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.initializeslip" title="Link to this definition">¶</a></dt>
<dd><p>Re-initializes the fault slip array to zero values.
Slip array will be the size of the number of patches/tents times the
3 components of slip (strike-slip, dip slip and tensile).</p>
<ul class="simple">
<li><p>1st Column is strike slip</p></li>
<li><p>2nd Column is dip slip</p></li>
<li><p>3rd Column is tensile</p></li>
</ul>
<dl class="simple">
<dt>Kwargs:</dt><dd><ul class="simple">
<li><p>n             : Number of slip values. If None, it’ll take the number of patches.</p></li>
<li><p>values        : Can be ‘depth’, ‘strike’, ‘dip’, ‘length’, ‘width’, ‘area’, ‘index’ or a numpy array. The array can be of size (n,3) or (n,1)</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>None</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.interpolateSlip">
<span class="sig-name descname"><span class="pre">interpolateSlip</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'strikeslip'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rebuild</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coord</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'LL'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.interpolateSlip" title="Link to this definition">¶</a></dt>
<dd><p>Creates an interpolator and interpolates the slip values to the 
position given in {lon} and {lat}.</p>
<dl class="field-list simple">
<dt class="field-odd">Args<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p>lon           : Longitude</p></li>
<li><p>lat           : Latitude</p></li>
</ul>
</dd>
<dt class="field-even">Kwargs<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p>slip          : Which slip value to take</p></li>
<li><p>rebuild       : Rebuild the interpolator</p></li>
<li><p>coord         : LL or utm (in km)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.patch2ll">
<span class="sig-name descname"><span class="pre">patch2ll</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.patch2ll" title="Link to this definition">¶</a></dt>
<dd><p>Takes all the patches in self.patch and convert them to lonlat.
Patches are stored in self.patchll</p>
<dl class="simple">
<dt>Returns:</dt><dd><ul class="simple">
<li><p>None</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.patch2xy">
<span class="sig-name descname"><span class="pre">patch2xy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.patch2xy" title="Link to this definition">¶</a></dt>
<dd><p>Takes all the patches in self.patchll and convert them to xy
Patches are stored in self.patch</p>
<dl class="simple">
<dt>Returns:</dt><dd><ul class="simple">
<li><p>None</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.pickle">
<span class="sig-name descname"><span class="pre">pickle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.pickle" title="Link to this definition">¶</a></dt>
<dd><p>Pickle myself.</p>
<dl class="field-list simple">
<dt class="field-odd">Args<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p>filename      : Name of the pickle fault.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.readPointSourcesFromPickle">
<span class="sig-name descname"><span class="pre">readPointSourcesFromPickle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.readPointSourcesFromPickle" title="Link to this definition">¶</a></dt>
<dd><p>Reads the point sources for computing Green’s functions with EDKS
from a pickle file. Sets the sources in self.edksSources</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>filename      : Name of the pickle file</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>None</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.rotateGFs">
<span class="sig-name descname"><span class="pre">rotateGFs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">azimuth</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.rotateGFs" title="Link to this definition">¶</a></dt>
<dd><p>For the data set data, returns the rotated GFs so that dip slip motion
is aligned with the azimuth. It uses the Greens functions stored
in self.G[data.name].</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>data          : Name of the data set.</p></li>
<li><p>azimuth       : Direction in which to rotate the GFs</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>rotatedGar    : GFs along the azimuth direction</p></li>
<li><p>rotatedGrp    : GFs in the direction perpendicular to the azimuth direction</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.saveData">
<span class="sig-name descname"><span class="pre">saveData</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'d'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outputDir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'.'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.saveData" title="Link to this definition">¶</a></dt>
<dd><p>Saves the Data in binary files.</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><ul class="simple">
<li><p>dtype       : Format of the binary data saved. ‘d’ for double. ‘f’ for np.float32</p></li>
<li><p>outputDir   : Directory to save binary data</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>None</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.saveGFs">
<span class="sig-name descname"><span class="pre">saveGFs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'d'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outputDir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'.'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">suffix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{'coupling':</span> <span class="pre">'Coupling',</span> <span class="pre">'dipslip':</span> <span class="pre">'DS',</span> <span class="pre">'strikeslip':</span> <span class="pre">'SS',</span> <span class="pre">'tensile':</span> <span class="pre">'TS'}</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.saveGFs" title="Link to this definition">¶</a></dt>
<dd><p>Saves the Green’s functions in different files.</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><ul class="simple">
<li><p>dtype       : Format of the binary data saved. ‘d’ for double. ‘f’ for np.float32</p></li>
<li><p>outputDir   : Directory to save binary data.</p></li>
<li><p>suffix      : suffix for GFs name (dictionary)</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>None</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.setCustomGFs">
<span class="sig-name descname"><span class="pre">setCustomGFs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.setCustomGFs" title="Link to this definition">¶</a></dt>
<dd><p>Sets a custom Green’s Functions matrix in the G dictionary.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>data          : Data concerned by the Green’s function</p></li>
<li><p>G             : Green’s function matrix</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>None</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.setGFs">
<span class="sig-name descname"><span class="pre">setGFs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strikeslip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[None,</span> <span class="pre">None,</span> <span class="pre">None]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dipslip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[None,</span> <span class="pre">None,</span> <span class="pre">None]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tensile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[None,</span> <span class="pre">None,</span> <span class="pre">None]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coupling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[None,</span> <span class="pre">None,</span> <span class="pre">None]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">synthetic</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.setGFs" title="Link to this definition">¶</a></dt>
<dd><p>Stores the input Green’s functions matrices into the fault structure.</p>
<p>These GFs are organized in a dictionary structure in self.G
Entries of self.G are the data set names (data.name). Entries of self.G[data.name] are ‘strikeslip’, ‘dipslip’, ‘tensile’ and/or ‘coupling’</p>
<p>If you provide GPS GFs, those are organised with E, N and U in lines</p>
<p>If you provide Optical GFs, those are organised with E and N in lines</p>
<p>If you provide InSAR GFs, these need to be projected onto the
LOS direction already.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>data          : Data structure</p></li>
</ul>
</dd>
<dt>Kwargs:</dt><dd><ul class="simple">
<li><p>strikeslip    : List of matrices of the Strikeslip Green’s functions</p></li>
<li><p>dipslip       : List of matrices of the dipslip Green’s functions</p></li>
<li><p>tensile       : List of matrices of the tensile Green’s functions</p></li>
<li><p>coupling      : List of matrices of the coupling Green’s function</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>None</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.setGFsFromFile">
<span class="sig-name descname"><span class="pre">setGFsFromFile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strikeslip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dipslip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tensile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coupling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">custom</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertical</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'d'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inDir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'.'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.setGFsFromFile" title="Link to this definition">¶</a></dt>
<dd><p>Sets the Green’s functions reading binary files. Be carefull, these have to be in the
good format (i.e. if it is GPS, then GF are E, then N, then U, optional, and
if insar, GF are projected already). Basically, it will work better if
you have computed the GFs using csi…</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>data          : Data object</p></li>
</ul>
</dd>
<dt>kwargs:</dt><dd><ul class="simple">
<li><p>strikeslip    : File containing the Green’s functions for strikeslip related displacements.</p></li>
<li><p>dipslip       : File containing the Green’s functions for dipslip related displacements.</p></li>
<li><p>tensile       : File containing the Green’s functions for tensile related displacements.</p></li>
<li><p>coupling      : File containing the Green’s functions for coupling related displacements.</p></li>
<li><p>vertical      : Deal with the UP component (gps: default is false, insar: it will be true anyway).</p></li>
<li><p>dtype         : Type of binary data. ‘d’ for double/float64. ‘f’ for np.float32</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>None</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.setTrace">
<span class="sig-name descname"><span class="pre">setTrace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delta_depth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'y'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.setTrace" title="Link to this definition">¶</a></dt>
<dd><p>Uses the patches to build a fault trace. Fault trace is made of the
vertices that are shallower than fault top + delta_depth
Fault trace is in self.xf and self.yf</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>delta_depth       : Depth extension below top of the fault</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.setmu">
<span class="sig-name descname"><span class="pre">setmu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tents</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.setmu" title="Link to this definition">¶</a></dt>
<dd><p>Gets the shear modulus corresponding to each patch using a model
file from the EDKS software. Shear moduli are set in self.mu</p>
<p>The model file format is as follows:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>N</p></th>
<th class="head"><p>F</p></th>
<th class="head"></th>
<th class="head"></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>RHO_1</p></td>
<td><p>VP_1</p></td>
<td><p>VS_1</p></td>
<td><p>TH_1</p></td>
</tr>
<tr class="row-odd"><td><p>RHO_2</p></td>
<td><p>VP_2</p></td>
<td><p>VS_2</p></td>
<td><p>TH_2</p></td>
</tr>
<tr class="row-even"><td><p>…</p></td>
<td><p>…</p></td>
<td><p>…</p></td>
<td><p>…</p></td>
</tr>
<tr class="row-odd"><td><p>RHO_N</p></td>
<td><p>VP_N</p></td>
<td><p>VS_N</p></td>
<td><p>TH_N</p></td>
</tr>
</tbody>
</table>
<p>where N is the number of layers, F a conversion factor to SI units
RHO_i is the density of the i-th layer
VP_i is the P-wave velocity in the i-th layer
VS_i is the S-wave velocity in the i-th layer
TH_i is the thickness of the i-th layer</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>model_file    : path to model file</p></li>
<li><p>tents         : if True, set mu values every point source in patches</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>None</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.slipIntegrate">
<span class="sig-name descname"><span class="pre">slipIntegrate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">slip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.slipIntegrate" title="Link to this definition">¶</a></dt>
<dd><p>Integrates slip on the patch by simply multiplying slip by the
patch area. Sets the results in self.volume</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><ul class="simple">
<li><p>slip  : Can be strikeslip, dipslip, tensile, coupling or a list/array of floats.</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>None</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.smoothTrace">
<span class="sig-name descname"><span class="pre">smoothTrace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">winsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">std</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">discretized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.smoothTrace" title="Link to this definition">¶</a></dt>
<dd><p>Smoothes the trace of the fault using a median filter (scipy.signal.medfilt)</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><ul class="simple">
<li><p>std               : Standard deviation of the Gaussian kernel in km</p></li>
<li><p>discretized       : Use the discretized fault trace (self.xi and self.yi) (default True)</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>None</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.strikeOfTrace">
<span class="sig-name descname"><span class="pre">strikeOfTrace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">discretized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">npoints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.strikeOfTrace" title="Link to this definition">¶</a></dt>
<dd><p>Computes the strike of the fault trace from the discretized (default) 
fault trace.</p>
<dl class="simple">
<dt>Kwargs:</dt><dd><ul class="simple">
<li><p>discretized       : Use the discretized fault trace (self.xi and self.yi) (default True)</p></li>
<li><p>npoints           : Number of points to average strike</p></li>
</ul>
</dd>
<dt>Return:</dt><dd><ul class="simple">
<li><p>None. Stores the strike in self.strike</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.sumPatches">
<span class="sig-name descname"><span class="pre">sumPatches</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iPatches</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">finalPatch</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.sumPatches" title="Link to this definition">¶</a></dt>
<dd><p>Takes a list of indexes of patches, sums the corresponding GFs and
replace the corresponding patches by the finalPatch in self.patch</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>patches       : List of the patche indexes to sum</p></li>
<li><p>finalPatch    : Geometry of the final patch.</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>None</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.surfaceGFs">
<span class="sig-name descname"><span class="pre">surfaceGFs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slipdir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'sd'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.surfaceGFs" title="Link to this definition">¶</a></dt>
<dd><p>Build the GFs for the surface slip case.
We assume the data are within the bounds of the fault.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>data      : surfaceslip data ojbect</p></li>
</ul>
</dd>
<dt>Kwargs:</dt><dd><ul class="simple">
<li><p>slipdir   : any combinatino of s and d. default: ‘sd’</p></li>
<li><p>verbose   : Default True</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.trace">
<span class="sig-name descname"><span class="pre">trace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">utm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.trace" title="Link to this definition">¶</a></dt>
<dd><p>Set the surface fault trace from Lat/Lon or UTM coordinates
Surface fault trace is stored in self.xf, self.yf (UTM) and
self.lon, self.lat (Lon/lat)</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>Lon           : Array/List containing the Lon points.</p></li>
<li><p>Lat           : Array/List containing the Lat points.</p></li>
</ul>
</dd>
<dt>Kwargs:</dt><dd><ul class="simple">
<li><p>utm           : If False, considers x and y are lon/lat. If True, considers x and y are utm in km</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>None</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.trace2ll">
<span class="sig-name descname"><span class="pre">trace2ll</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.trace2ll" title="Link to this definition">¶</a></dt>
<dd><p>Transpose the fault trace UTM coordinates into lat/lon.
Lon/Lat coordinates are stored in self.lon and self.lat in degrees</p>
<dl class="simple">
<dt>Returns:</dt><dd><ul class="simple">
<li><p>None</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.trace2xy">
<span class="sig-name descname"><span class="pre">trace2xy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.trace2xy" title="Link to this definition">¶</a></dt>
<dd><p>Transpose the fault trace lat/lon into the UTM reference.
UTM coordinates are stored in self.xf and self.yf in km</p>
<dl class="simple">
<dt>Returns:</dt><dd><ul class="simple">
<li><p>None</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.writePatchesCenters2File">
<span class="sig-name descname"><span class="pre">writePatchesCenters2File</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">slip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.writePatchesCenters2File" title="Link to this definition">¶</a></dt>
<dd><p>Write the patch center coordinates in an ascii file
the file format is so that it can by used directly in psxyz (GMT).</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>filename      : Name of the file.</p></li>
</ul>
</dd>
<dt>Kwargs:</dt><dd><ul class="simple">
<li><p>slip          : Put the slip as a value for the color. Can be None, strikeslip, dipslip, total, coupling</p></li>
<li><p>scale         : Multiply the slip value by a factor.</p></li>
</ul>
</dd>
<dt>Retunrs:</dt><dd><ul class="simple">
<li><p>None</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.writePointSources2Pickle">
<span class="sig-name descname"><span class="pre">writePointSources2Pickle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.writePointSources2Pickle" title="Link to this definition">¶</a></dt>
<dd><p>Writes the point sources to a pickle file.
Always writes the Facet based point sources.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>filename      : Name of the pickle file.</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>None</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="csi.Fault.writeTrace2File">
<span class="sig-name descname"><span class="pre">writeTrace2File</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'lonlat'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.writeTrace2File" title="Link to this definition">¶</a></dt>
<dd><p>Writes the trace to a file. Format is ascii with two columns with
either lon/lat (in degrees) or x/y (utm in km).</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>filename      : Name of the file</p></li>
</ul>
</dd>
<dt>Kwargs:</dt><dd><ul class="simple">
<li><p>ref           : can be lonlat or utm.</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><ul class="simple">
<li><p>None</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">CSI</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../basictutorials.html">Basic Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CSIpublications.html">CSI Publications</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../classes.html">Classes</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="../classes.html">Classes</a><ul>
  <li><a href="../faultclasses.html">Classes of faults</a><ul>
      <li>Previous: <a href="../faultclasses.html" title="previous chapter">Classes of faults</a></li>
      <li>Next: <a href="fault3D.html" title="next chapter">fault3D class</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, Romain Jolivet.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
      |
      <a href="../_sources/classes/Fault.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>